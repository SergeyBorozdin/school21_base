#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef struct options {
  int b;  //нумерует не пустые строки
  int e;  // показывает конец строки
  int n;  // нумерует все строки
  int s;  // сжимает пустые строки до одной
  int t;  // показыввает табы
  int v;  // показывает не читаемые символы
} opt;

void cat_not_arg() {
  char symbol;
  while (scanf("%c", &symbol)) {
    printf("%c", symbol);
  }
}

void parser(int argc, char *argv[], opt *options) {
  int opt = 0;
  int option_index = 0;
  struct option opts[] = {
      {"number-nonblank", 0, 0, 'b'},
      {"show-ends", 0, 0, 'e'},
      {"number", 0, 0, 'n'},
      {"squeeze-blank", 0, 0, 's'},
      {"show-tabs", 0, 0, 't'},
      {"show-nonprinting", 0, 0, 'v'},
      {0, 0, 0, 0},
  };

  while (-1 !=
         (opt = getopt_long(argc, argv, "+benstvTE", opts, &option_index))) {
    switch (opt) {
      case 'b':
        options->b = 1;
        break;
      case 'e':
        options->e = 1;
        options->v = 1;
        break;
      case 'n':
        options->n = 1;
        break;
      case 's':
        options->s = 1;
        break;
      case 't':
        options->t = 1;
        options->v = 1;
        break;
      case 'v':
        options->v = 1;
        break;
      case 'E':
        options->e = 1;
        options->v = 1;
        break;
      case 'T':
        options->t = 1;
        break;
      default:
        fprintf(stderr, "usage - 'benstvTE'");
        exit(1);
    }
  }
}

void reader(int argc, char *argv[], opt options) {
  for (int i = 1; i < argc; i++) {
    if (*argv[i] == '-') {
      continue;
    } else {
      FILE *fp = fopen(argv[i], "r");

      if (fp != NULL) {
        int symbol = 0;
        int symbol_prev = 10;
        int flag_bool_s = 0;
        int str_count = 0;
        int i = 0;

        while ((symbol = fgetc(fp)) != EOF) {
          if (symbol_prev == '\n') {
            if (options.s == 1) {
              if (symbol == '\n') {
                if (flag_bool_s == 1) {
                  continue;
                }
                flag_bool_s = 1;
              } else {
                flag_bool_s = 0;
              }
            }
          }
          if ((options.n == 1 && options.b == 0) ||
              (options.b == 1 && symbol != '\n' && symbol_prev == '\n')) {
            printf("%6d\t", ++str_count);
          }
          // if (options.b == 1) {
          //   if (symbol != '\n') {
          //     printf("%6d\t", ++str_count);
          //   }
          // }
          // if (options.n == 1) {
          //   if (i == 0) {
          //     printf("%6d\t", ++str_count);
          //     symbol_prev = 0;
          //   }
          //   if (symbol_prev == '\n') {
          //     printf("%6d\t", ++str_count);
          //   }
          // }

          if (symbol == '\n') {
            if (options.e == 1) {
              if (symbol == '\n') {
                printf("%c", '$');
              }
            }
          }
          if (symbol == '\t') {
            if (options.t == 1) {
              printf("%c%c", '^', 'I');
              continue;
            }
          }
          if (options.v == 1) {
            if ((symbol >= 0 && symbol < 9) || (symbol > 10 && symbol < 32)) {
              printf("^%c", symbol + 64);
              continue;
            }
            if (symbol == 127) {
              printf("^%c", '?');
              continue;
            }
          }

          printf("%c", symbol);
          symbol_prev = symbol;
          i++;
        }
      } else {
        printf("%s: %s: No such file or directory\n", argv[0], argv[i]);
      }
    }
  }
}

int main(int argc, char *argv[]) {
  if (argc == 1) {
    cat_not_arg();
  }

  opt options = {0, 0, 0, 0, 0, 0};
  parser(argc, argv, &options);
  reader(argc, argv, options);

  return 0;
}
